1. Gestione degli errori

try:
    df = api_retrieving(data_source, fields, start_date, end_date)
except Exception as e:
    st.error(f"Errore nel recupero dei dati: {str(e)}")
    return

2. Inserimento delle opportunità "createdAt" vs "lastStageChangeAt"

3. Ottimizzazione delle query del database

# Utilizzare indici appropriati nel database
# Limitare i dati recuperati solo a quelli necessari
query = """
    SELECT createdAt, lastStageChangeAt, monetaryValue, stage
    FROM opportunities
    WHERE locationId = %s AND createdAt BETWEEN %s AND %s
"""
cursor.execute(query, (st.secrets.id_cliente, start_date, end_date))

4. Caching dei risultati

@st.cache_data
def fetch_and_process_data(start_date, end_date):
    # Logica per recuperare e processare i dati
    return processed_data

# Uso:
data = fetch_and_process_data(start_date, end_date)

6. Utilizzo di list comprehension e funzioni di aggregazione

# Invece di cicli for
filtered_counts = {stage: opportunitàPerStage.get(stage, 0) for stage in opportunitàPerse}

# Utilizzare funzioni di aggregazione di pandas
df.groupby('stage')['monetaryValue'].sum()